# Supabase Integration Architecture Report

**Date:** 2025-12-05
**Author:** Amelia (Developer Agent)
**Story:** 2.1 - Implement User Registration & Login

## Overview

This report explains the implementation of Supabase as the primary authentication and identity provider for the ibe160 platform. By offloading identity management to Supabase, we achieve a secure, stateless, and scalable authentication system while maintaining strict control over application data.

## 1. System Architecture

Instead of the backend handling user passwords, sessions, and email verification directly, these responsibilities are delegated to Supabase.

- **Supabase Auth:** Acts as the Identity Provider (IdP). It manages the `auth.users` table, handles password encryption (bcrypt), generates JWTs, and manages email flows (verification, password reset).
- **FastAPI Backend:** Acts as the Resource Server. It trusts the identity of users by validating the JWTs generated by Supabase. It does NOT store passwords.
- **PostgreSQL Database:** Stores application-specific data (Controls, Risks) and links them to users via their unique Supabase User ID (UUID).

## 2. Frontend Authentication Flow

The frontend (`frontend/app/(auth)/*`) interacts directly with Supabase APIs using the `@supabase/ssr` and `@supabase/supabase-js` libraries.

### Registration (`/register`)
1.  User enters email and password.
2.  Frontend calls `supabase.auth.signUp({ email, password })`.
3.  Supabase creates a new user entry in its hosted `auth.users` table.
4.  Supabase triggers a verification email (configured to use SendGrid in production).
5.  User receives a link to verify their email address.

### Login (`/login`)
1.  User enters email and password.
2.  Frontend calls `supabase.auth.signInWithPassword({ email, password })`.
3.  Supabase verifies credentials and returns a **Session** object containing:
    -   **Access Token (JWT):** Short-lived token used to authenticate API requests.
    -   **Refresh Token:** Long-lived token used to get new access tokens.
4.  The `@supabase/ssr` library automatically handles storing these tokens in secure, HTTP-only cookies.

### API Requests
For every request to the backend (e.g., `GET /api/v1/controls`), the frontend middleware/client attaches the Access Token to the `Authorization` header:
```http
Authorization: Bearer <eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...>
```

## 3. Backend Verification Logic

The backend (`backend/app/core/security.py`) uses a stateless verification strategy. It does not need to query the database to authenticate a user for every request.

### The `get_current_user` Dependency
This function is injected into protected routes:

1.  **Extract:** It reads the JWT from the `Authorization` header.
2.  **Validate Signature:** It uses the `SUPABASE_JWT_SECRET` (shared secret) to verify the token was signed by Supabase and has not been tampered with.
3.  **Validate Claims:** It checks standard claims like expiration (`exp`) and audience (`aud`).
4.  **Extract Identity:** It retrieves the `sub` (Subject ID / User UUID) from the token.
5.  **Extract Metadata:** It retrieves custom claims like `role` and `tenant_id` from `app_metadata` inside the token.

If validation fails (expired, invalid signature), it raises a `401 Unauthorized` error.

## 4. User Data & Role Management

We utilize a dual-storage approach for user data to balance security and application needs.

- **Identity Store (Supabase):**
    -   Table: `auth.users` (Managed by Supabase)
    -   Data: Email, Password Hash, Last Login, Email Verified status.
    -   Metadata: `role` and `tenant_id` are stored in `raw_app_meta_data`. This ensures they are always present in the JWT.

- **Application Store (Local Postgres):**
    -   Table: `public.user` (Managed by us via SQLAlchemy)
    -   Data: `id` (Matches Supabase UUID), `email`, `role`, `tenant_id`, and relationships to other tables (e.g., `items`).
    -   **Reason:** We need a local table to satisfy foreign key constraints (e.g., "This Control was created by User X").

**Synchronization:**
For this MVP, we assume alignment based on UUID. In a production scenario, a Supabase Database Trigger would be used to automatically insert a row into `public.user` whenever a new user is created in `auth.users`.

## 5. Configuration Checklist

To replicate this environment, the following configuration is required:

### Environment Variables
| Variable | Description | Location |
| :--- | :--- | :--- |
| `NEXT_PUBLIC_SUPABASE_URL` | Your Supabase Project URL | Frontend |
| `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Public API Key for client-side calls | Frontend |
| `SUPABASE_JWT_SECRET` | Secret used to sign/verify tokens | Backend |

### Supabase Dashboard Settings
1.  **Auth Providers:** Enable Email/Password.
2.  **Email Templates:** Configure "Confirm Your Signup" template.
3.  **Token Settings:** Set Access Token expiration (default 1 hour).

Refer to `docs/setup/supabase-configuration.md` for the step-by-step setup guide.
